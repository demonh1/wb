////////
#define FT_LONG             1
#define FT_CHAR             2
#define FT_BYTE             3

#define DP_HEXCHAR_CHAR     0x00000001
#define DP_HEXCHAR_BYTE     0x00000002

MQMD2 DefaultMqmd = { MQMD2_DEFAULT };                           /*@1C*/

#define CSOFFSETOF(s,c) (int)(ptrdiff_t)&(((s *)0)->c)

typedef struct _FLD
{
  int    Type;                         /* FT_*                        */
  int    Offset;
  int    Length;
  int    Version;
  char * Id;
  char * Name;
  int    Depend;
} FLD;


FLD Flds[] = {
{ FT_LONG, CSOFFSETOF(MQMD,Version)          , 4, 2,"VER","Version"},
{ FT_LONG, CSOFFSETOF(MQMD,Report)           , 4, 0,"RPT","Report" },
{ FT_LONG, CSOFFSETOF(MQMD,MsgType)          , 4, 0,"MST","MsgType" },
{ FT_LONG, CSOFFSETOF(MQMD,Expiry)           , 4, 0,"EXP","Expiry" },
{ FT_LONG, CSOFFSETOF(MQMD,Feedback)         , 4, 0,"FDB","Feedback" },
{ FT_LONG, CSOFFSETOF(MQMD,Encoding)         , 4, 0,"ENC","Encoding" },
{ FT_LONG, CSOFFSETOF(MQMD,CodedCharSetId)   , 4, 0,"CCS","CodedCharSetId" },
{ FT_CHAR, CSOFFSETOF(MQMD,Format)           , 8, 0,"FMT","Format" },
{ FT_LONG, CSOFFSETOF(MQMD,Priority)         , 4, 0,"PRI","Priority"},
{ FT_LONG, CSOFFSETOF(MQMD,Persistence)      , 4, 0,"PER","Persistence"},
{ FT_BYTE, CSOFFSETOF(MQMD,MsgId)            ,24, 0,"MSI","MsgId"},
{ FT_BYTE, CSOFFSETOF(MQMD,CorrelId)         ,24, 0,"COI","CorrelId"},
{ FT_LONG, CSOFFSETOF(MQMD,BackoutCount)     , 4, 0,"BOC","BackoutCount"},
{ FT_CHAR, CSOFFSETOF(MQMD,ReplyToQ)         ,48, 0,"RTQ","ReplyToQ"},
{ FT_CHAR, CSOFFSETOF(MQMD,ReplyToQMgr)      ,48, 0,"RTM","ReplyToQMgr"},
{ FT_CHAR, CSOFFSETOF(MQMD,UserIdentifier)   ,12, 0,"USR","UserIdentifier"},
{ FT_BYTE, CSOFFSETOF(MQMD,AccountingToken)  ,32, 0,"ACC","AccountingToken"},
{ FT_CHAR, CSOFFSETOF(MQMD,ApplIdentityData) ,32, 0,"AID","ApplIdentityData", DP_HEXCHAR_CHAR},
{ FT_BYTE, CSOFFSETOF(MQMD,ApplIdentityData) ,32, 0,"AIX","ApplIdentityData", DP_HEXCHAR_BYTE},
{ FT_LONG, CSOFFSETOF(MQMD,PutApplType)      , 4, 0,"PAT","PutApplType"},
{ FT_CHAR, CSOFFSETOF(MQMD,PutApplName)      ,28, 0,"PAN","PutApplName"},
{ FT_CHAR, CSOFFSETOF(MQMD,PutDate)          , 8, 0,"PTD","PutDate"},
{ FT_CHAR, CSOFFSETOF(MQMD,PutTime)          , 8, 0,"PTT","PutTime"},
{ FT_CHAR, CSOFFSETOF(MQMD,ApplOriginData)   , 4, 0,"AOD","ApplOriginData", DP_HEXCHAR_CHAR},
{ FT_BYTE, CSOFFSETOF(MQMD,ApplOriginData)   , 4, 0,"AOX","ApplOriginData", DP_HEXCHAR_BYTE},

{ FT_CHAR, CSOFFSETOF(MQMD,StrucId)          , 4, 0,""   ,"StrucId"},
{ FT_BYTE, CSOFFSETOF(MQMD2,GroupId)         ,24, 2,"GRP","GroupId"},
{ FT_LONG, CSOFFSETOF(MQMD2,MsgSeqNumber)    , 4, 2,"MSQ","MsgSeqNumber"},
{ FT_LONG, CSOFFSETOF(MQMD2,Offset)          , 4, 2,"OFF","Offset"},
{ FT_LONG, CSOFFSETOF(MQMD2,MsgFlags)        , 4, 2,"MSF","MsgFlags"},
{ FT_LONG, CSOFFSETOF(MQMD2,OriginalLength)  , 4, 2,"ORL","OriginalLength"},
{ 0      , 0                                , 0, 0,""   ,""}
};

///////
size_t split(const std::string& src, const std::string& delim, std::set<std::string>& parts){
    parts.clear();

    std::string::const_iterator cit, cur = src.begin(), end = src.end();

    if(cur == end)
        return 0;

    while(  (cit = std::search(cur, src.end(), delim.begin(), delim.end() ) ) != end )
    {
        if(cur != cit)
        {
            std::string strCurrent;
            std::copy(cur, cit, std::back_inserter(strCurrent));
	    	parts.insert(strCurrent);
        }
        cur = cit + delim.size();
    }
    if(cur != cit)
    {
        std::string strCurrent;
        std::copy(cur, cit, std::back_inserter(strCurrent));
		parts.insert(strCurrent);
    }
    return parts.size();
	}
//////////

bool process(const char* filename, ImgMsg& msg ) 
{
		
		std::string line;
		std::ifstream file( filename, std::ios_base::in | std::ios_base::binary );
		
		if( !file.is_open() ){ return false; }


		while (std::getline(file, line))
		{
			
			if (line.empty()) continue;
			if (memcmp(line.c_str(),"* QLOAD",7) != 0 && memcmp(line.c_str(),"* DMPMQMSG",10) != 0) return false;
			
			if (line[0] == 'A'){
			// TODO: switch-case to fields
			// msg.setExpiry(e);
			}
			if(line[0] == 'S'){
			}

			

		}
    return true;
}

//
